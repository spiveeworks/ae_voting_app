<!DOCTYPE html>
<html>
<body>

<script type="module">
    import * as sk from "../sidekick.js";

    // account selection 'login' stuff
    var logged_in = false;
    var address;

    // cache of poll categories
    var poll_categories = {};
    window.poll_categories = poll_categories;

    var author_categories = {};
    window.author_categories = author_categories;

    var permissions = {};
    window.permissions = permissions;

    function connect(logger) {
        return sk.connect(
            'ske-connect-1',
            {name: 'sidekick examples',
             version: 1},
            sk.TIMEOUT_DEF_CONNECT_MS,
            "failed to connect to wallet",
            logger
        );
    }

    function sign_tx(logger, tx) {
        let sign_params = {
            tx: tx,
            returnSigned: true,
            networkId: "ae_uat"
        };
        return sk.tx_sign_noprop('sk-tx-sign-1', sign_params, sk.TIMEOUT_DEF_TX_SIGN_NOPROP_MS, 'sign transaction timed out', logger);
    }

    // This is the first half of login() from show_poll.html - factor these?
    async function login() {
        let logger = sk.cl();

        await connect(logger);
        let wallet_info = await sk.address(
            'ske-address-1',
            {type: 'subscribe',
             value: 'connected'},
            sk.TIMEOUT_DEF_ADDRESS_MS,
            "failed to address to wallet",
            logger
        );
        if (!wallet_info.ok) return;

        let maybe_address = Object.keys(wallet_info.result.address.current)[0];
        if (maybe_address === undefined) return;

        address = maybe_address;
        logged_in = true;
        document.getElementById("login_status").innerHTML = "Viewing as " + address;
        document.getElementById("login_button").innerText = "Change account";
    }

    // this also appears in show_poll.html - util module?
    async function post_json(url, body) {
        let response = await fetch(
            url,
            {
                method: "post",
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
            }
        );

        if (response.ok) {
            let body = await response.json();
            return {ok: true, body: body};
        } else {
            return response;
        }
    }

    function sign_message(logger, message) {
        let promise = sk.msg_sign(
            'ske-msg_sign-1',
            address,
            message,
            sk.TIMEOUT_DEF_MSG_SIGN_MS,
            'sign message timed out',
            logger
        );

        return promise;
    }

    // this is probably pretty redundant with vote and revoke in
    // show_poll.html, might want to look and see what can be factored there,
    // if anything.
    async function updatePollCategory(poll_id, category) {
        if (!logged_in) return false;

        let logger = sk.cl();

        // message formation

        let action_req_body = {
            poll_id: poll_id,
            category: category,
            address: address
        };
        let action_resp = await post_json("/api/setPollCategory/formMessage", action_req_body);
        if (!action_resp.ok) return false;

        let ts = action_resp.body.timestamp;
        let nonce = action_resp.body.nonce;
        let message = action_resp.body.message;

        // sign message

        let sign_result = await sign_message(logger, message);
        if (!sign_result.ok) return false;

        let signature = sign_result.result.signature;

        // submit signature

        let submit_req_body = {
            poll_id: poll_id,
            category: category,
            address: address,
            timestamp: ts,
            nonce: nonce,
            message_signature: signature
        };
        let submit_resp = await post_json("/api/setPollCategory/submitSig", submit_req_body);

        return submit_resp.ok;
    }

    async function updateAuthorCategory(author, category) {
        if (!logged_in) return false;

        let logger = sk.cl();

        // message formation

        let action_req_body = {
            account: author,
            category: category,
            address: address
        };
        let action_resp = await post_json("/api/setAccountCategory/formMessage", action_req_body);
        if (!action_resp.ok) return false;

        let ts = action_resp.body.timestamp;
        let nonce = action_resp.body.nonce;
        let message = action_resp.body.message;

        // sign message

        let sign_result = await sign_message(logger, message);
        if (!sign_result.ok) return false;

        let signature = sign_result.result.signature;

        // submit signature

        let submit_req_body = {
            account: author,
            category: category,
            address: address,
            timestamp: ts,
            nonce: nonce,
            message_signature: signature
        };
        let submit_resp = await post_json("/api/setAccountCategory/submitSig", submit_req_body);

        return submit_resp.ok;
    }

    async function updatePermissions(author, permission_level) {
        if (!logged_in) return false;

        let logger = sk.cl();

        // message formation

        let action_req_body = {
            account: author,
            permission_level: permission_level,
            address: address
        };
        let action_resp = await post_json("/api/setAccountPermissions/formMessage", action_req_body);
        if (!action_resp.ok) return false;

        let ts = action_resp.body.timestamp;
        let nonce = action_resp.body.nonce;
        let message = action_resp.body.message;

        // sign message

        let sign_result = await sign_message(logger, message);
        if (!sign_result.ok) return false;

        let signature = sign_result.result.signature;

        // submit signature

        let submit_req_body = {
            account: author,
            permission_level: permission_level,
            address: address,
            timestamp: ts,
            nonce: nonce,
            message_signature: signature
        };
        let submit_resp = await post_json("/api/setAccountPermissions/submitSig", submit_req_body);

        return submit_resp.ok;
    }

    function createPollDropdown(poll_index, selected, out_node) {
        let menu = document.createElement("select");

        const options = ["default", "official", "approved", "all", "hidden"];

        for (var i = 0; i < options.length; i++) {
            let op = document.createElement("option");
            op.text = options[i];
            menu.add(op);

            if (options[i] == selected) {
                menu.selectedIndex = i;
            }
        }

        let button = document.createElement("button");
        button.innerText = "update";
        button.disabled = true;

        menu.onchange = makeDropdownClosure(poll_index, poll_categories, menu, button);
        button.onclick = makeButtonClosure(poll_index, poll_categories, updatePollCategory, menu, button, out_node);
        return [menu, button];
    }

    function createAuthorDropdown(author, selected, out_node) {
        let menu = document.createElement("select");

        const options = ["official", "approved", "all", "hidden"];

        for (var i = 0; i < options.length; i++) {
            let op = document.createElement("option");
            op.text = options[i];
            menu.add(op);

            if (options[i] == selected) {
                menu.selectedIndex = i;
            }
        }

        let button = document.createElement("button");
        button.innerText = "update";
        button.disabled = true;

        menu.onchange = makeDropdownClosure(author, author_categories, menu, button);
        button.onclick = makeButtonClosure(author, author_categories, updateAuthorCategory, menu, button, out_node);

        return [menu, button];
    }

    function createAuthorPermissionsDropdown(author, selected, out_node) {
        let menu = document.createElement("select");

        const options = ["none", "can_create_polls", "can_set_categories",
                         "can_change_permissions"];

        for (var i = 0; i < options.length; i++) {
            let op = document.createElement("option");
            op.text = options[i];
            menu.add(op);

            if (options[i] == selected) {
                menu.selectedIndex = i;
            }
        }

        let button = document.createElement("button");
        button.innerText = "update";
        button.disabled = true;

        menu.onchange = makeDropdownClosure(author, permissions, menu, button);
        button.onclick = makeButtonClosure(author, permissions, updatePermissions, menu, button, out_node);

        return [menu, button];
    }


    function makeDropdownClosure(address, categories, menu, button) {
        function f() {
            const choice = menu.options[menu.selectedIndex].text;
            const actual = categories[address];
            // Grey out button if the selected choice already matches what the
            // server last told us the category is.
            button.disabled = choice == actual;
        }
        return f;
    }

    function makeButtonClosure(address, categories, update, menu, button, out_node) {
        async function f() {
            const category = menu.options[menu.selectedIndex].text;
            let success = await update(address, category);
            if (success) {
                categories[address] = category;
                out_node.textContent = category;
                // similar to the onchange action created by
                // makeDropdownClosure, but this time based on the selected
                // category, and a previous selected category, which is now the
                // actual category server-side.
                const selected_now = menu.options[menu.selectedIndex].text;
                button.disabled = selected_now == category;
            }
        }
        return f;
    }

    function generatePollTable(data) {
        let table = document.getElementById("poll_table");

        for (let element of data) {
            let row = table.insertRow();

            // Add a column for the poll id
            row.insertCell()
               .appendChild(document.createTextNode("" + element.id + ": " + element.title));
            row.insertCell()
               .appendChild(document.createTextNode(element.close_height));

            let category = poll_categories[element.id];
            let category_text_node = document.createTextNode(category);
            row.insertCell()
               .appendChild(category_text_node);

            let [menu, button] = createPollDropdown(element.id, category,
                                                    category_text_node);
            row.insertCell()
               .appendChild(menu);
            row.insertCell()
               .appendChild(button);
        }

        // Generate the head AFTER the body, because of course.
        let thead = table.createTHead();
        let row = thead.insertRow();

        let th1 = document.createElement("th");
        th1.appendChild(document.createTextNode("Poll"));
        row.appendChild(th1);

        let th2 = document.createElement("th");
        th2.appendChild(document.createTextNode("Close Height"));
        row.appendChild(th2);

        let th3 = document.createElement("th");
        th3.appendChild(document.createTextNode("Category"));
        row.appendChild(th3);
    }

    function addAuthorTableRow(author, category, permission_level) {
        let table = document.getElementById("author_table");

        let row = table.insertRow();

        row.insertCell()
           .appendChild(document.createTextNode(author));

        let category_text_node = document.createTextNode(category);
        row.insertCell()
           .appendChild(category_text_node);

        let [menu, button] = createAuthorDropdown(author, category, category_text_node);
        row.insertCell()
           .appendChild(menu);
        row.insertCell()
           .appendChild(button);

        let permission_text_node = document.createTextNode(permission_level);
        row.insertCell()
           .appendChild(permission_text_node);
        let [pmenu, pbutton] = createAuthorPermissionsDropdown(author, permission_level, permission_text_node);
        row.insertCell()
           .appendChild(pmenu);
        row.insertCell()
           .appendChild(pbutton);
    }

    function generateAuthorTable(data, permissions) {
        let table = document.getElementById("author_table");

        for (let [author, category] of Object.entries(author_categories)) {
            var permission_level = "none";
            if (author in permissions) {
                permission_level = permissions[author];
            }
            addAuthorTableRow(author, category, permission_level);
        }

        for (let [user, permission_level] of Object.entries(permissions)) {
            if (!(user in author_categories)) {
                addAuthorTableRow(user, "all", permission_level);
            }
        }

        // Generate the head AFTER the body, because of course.
        let thead = table.createTHead();
        let row = thead.insertRow();

        let th1 = document.createElement("th");
        th1.appendChild(document.createTextNode("Account"));
        row.appendChild(th1);

        let th2 = document.createElement("th");
        th2.appendChild(document.createTextNode("Category"));
        row.appendChild(th2);

        row.appendChild(document.createElement("th"));
        row.appendChild(document.createElement("th"));

        let th5 = document.createElement("th");
        th5.appendChild(document.createTextNode("Permissions"));
        row.appendChild(th5);
    }

    async function updatePolls() {
        let login_button = document.getElementById("login_button");
        login_button.innerText = "Select account";
        login_button.onclick = login;

        let polls_string = await fetch("/api/getPolls?category=hidden");
        let polls = await polls_string.json();
        let settings_string = await fetch("/api/categorySettings");
        let settings = await settings_string.json();
        let permissions_string = await fetch("/api/permissionSettings");
        permissions = await permissions_string.json();

        poll_categories = settings.poll_categories;
        window.poll_categories = poll_categories;

        author_categories = settings.account_categories;
        window.author_categories = author_categories;

        window.permissions = permissions;

        generatePollTable(polls.polls);

        generateAuthorTable(polls.polls, permissions);
    }

    window.onload = updatePolls;
    //setInterval(updateCounter, 1000);
</script>

<p id="login_status">No account selected.</p>

<button id="login_button">Loading...</button>

<h3>Poll categories:</h3>

<table id="poll_table">
<!-- to be generated client-side --!>
</table>

<h3>Poll Creators and Curators:</h3>

<table id="author_table">
<!-- to be generated client-side --!>
</table>

</body>
</html>

